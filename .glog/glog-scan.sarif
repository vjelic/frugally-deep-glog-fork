{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "d3e64a1b-2e1f-3be7-a4e7-ea2dd7741965",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the analysis classified it as a risk of undefined behavior due to possible overlap between the source and destination memory regions in a memory copy operation. The code uses a memory copy function to transfer data from one buffer to another, but there is evidence that the source and destination may refer to overlapping memory regions, as indicated by an alias assignment. This can lead to unpredictable results or program crashes. Additionally, there are no explicit checks to ensure that the source and destination pointers are non-null, which increases the risk of undefined behavior. No guards or capacity checks are present to mitigate these risks.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory, ensure that the source and destination buffers do not overlap. If there is any possibility of overlap, use a memory move function that is safe for overlapping regions. Additionally, add explicit checks to ensure that neither the source nor the destination pointers are null before performing the copy operation. For example:\n\n```cpp\nif (result && m && result->data() && m.data()) {\n    // If overlap is possible, use memmove instead of memcpy\n    std::memmove(result->data(), m.data(), result->size() * sizeof(float_type));\n}\n```\n\nThis approach ensures that the operation is safe even if the source and destination memory regions overlap, and it avoids dereferencing null pointers. Always validate buffer sizes and pointer validity before performing memory operations.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "39ab219f-8268-3ae0-b7c6-ca4b687357ea",
              "help": {
                "text": "",
                "markdown": "This finding is classified as a genuine vulnerability because it is marked as a high-confidence undefined behavior risk due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may refer to overlapping memory, which can cause undefined behavior when using functions like memcpy. Additionally, there are no explicit checks or guards ensuring that the source and destination are non-overlapping or non-null, increasing the risk. The source and destination are both derived from data containers, and dataflow analysis suggests a possible overlap. This makes the issue actionable and not a likely false positive.\n\n## In Context Remediation\nTo prevent undefined behavior when copying memory between potentially overlapping regions, use a function that is safe for overlapping memory, such as `std::memmove`, instead of `std::memcpy`. `std::memmove` is specifically designed to handle overlapping source and destination buffers safely.\n\n```cpp\nstd::memmove(m.data(), values.data(), values.size() * sizeof(float_type));\n```\n\nAdditionally, ensure that both `m.data()` and `values.data()` are not null before performing the copy to avoid null pointer dereference:\n\n```cpp\nif (m.data() != nullptr && values.data() != nullptr) {\n    std::memmove(m.data(), values.data(), values.size() * sizeof(float_type));\n}\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "d3e64a1b-2e1f-3be7-a4e7-ea2dd7741965",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fdeep/tensor.hpp"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 13,
                  "endLine": 927,
                  "endColumn": 60,
                  "charOffset": 39555,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(result->data(), m.data(), result->size()",
                    "rendered": {
                      "text": "memcpy(result->data(), m.data(), result->size()",
                      "markdown": "`memcpy(result->data(), m.data(), result->size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fdeep/tensor.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39555,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(result->data(), <size of result->data()>,  m.data(),  result->size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "39ab219f-8268-3ae0-b7c6-ca4b687357ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fdeep/tensor.hpp"
                },
                "region": {
                  "startLine": 919,
                  "startColumn": 13,
                  "endLine": 919,
                  "endColumn": 58,
                  "charOffset": 39215,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(m.data(), values.data(), values.size()",
                    "rendered": {
                      "text": "memcpy(m.data(), values.data(), values.size()",
                      "markdown": "`memcpy(m.data(), values.data(), values.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fdeep/tensor.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39215,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m.data(), <size of m.data()>,  values.data(),  values.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}