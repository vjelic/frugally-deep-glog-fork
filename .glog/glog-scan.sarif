{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "d3e64a1b-2e1f-3be7-a4e7-ea2dd7741965",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis observed that the destination and source may be aliases of each other, which can lead to undefined behavior when using memory copy functions like memcpy. Additionally, there are no explicit checks to ensure that the source and destination pointers are not null, increasing the risk of null pointer dereference. The absence of bounds or overlap guards further increases the risk. The verdict is supported by the high-confidence classification and the lack of mitigating controls in the code.\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. Add a runtime check to verify that the memory ranges are either completely disjoint or use a safe copy function if overlap is possible. For example:\n\n```cpp\nif (result->data() != m.data()) {\n    std::memcpy(result->data(), m.data(), result->size() * sizeof(float_type));\n} else {\n    // Handle the case where source and destination are the same, if needed\n}\n```\nThis prevents undefined behavior by ensuring that memcpy is only called when the memory regions do not overlap.\n\n## In Context Remediation 2\nIf there is any possibility that the source and destination memory regions may overlap, replace the memory copy operation with `std::memmove`, which is safe for overlapping regions:\n\n```cpp\nstd::memmove(result->data(), m.data(), result->size() * sizeof(float_type));\n```\nThis change ensures that the copy operation is well-defined even if the memory regions overlap.\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Glossary: Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "39ab219f-8268-3ae0-b7c6-ca4b687357ea",
              "help": {
                "text": "",
                "markdown": "This finding is considered a genuine vulnerability because the classification indicates a risk of undefined behavior due to possible overlap between the source and destination memory regions in the memory copy operation. The analysis detected that the source and destination may refer to overlapping memory areas, which is not allowed for the standard memory copy function and can result in unpredictable program behavior. Additionally, there are no explicit checks to ensure that the source and destination pointers are non-null, increasing the risk of null pointer dereference. The absence of bounds checks or guards further increases the risk. The verdict is supported by the high-confidence classification and the automated assessment that overlap is feasible based on data flow analysis.\n\n## In Context Remediation 1\nBefore performing the memory copy, ensure that the source and destination memory regions do not overlap. Add a runtime check to verify that the memory ranges are either completely disjoint or use a safe copy function if overlap is possible. For example:\n\n```cpp\nconst void* src_ptr = values.data();\nvoid* dst_ptr = m.data();\nsize_t num_bytes = values.size() * sizeof(float_type);\nif ((static_cast<const char*>(src_ptr) + num_bytes <= static_cast<const char*>(dst_ptr)) ||\n    (static_cast<const char*>(dst_ptr) + num_bytes <= static_cast<const char*>(src_ptr))) {\n    std::memcpy(dst_ptr, src_ptr, num_bytes);\n} else {\n    // Handle overlap safely, e.g., use memmove or throw an error\n}\n```\n\n\n## In Context Remediation 2\nIf there is any possibility that the source and destination memory regions may overlap, replace the memory copy function with a function that is safe for overlapping regions, such as memmove:\n\n```cpp\nstd::memmove(m.data(), values.data(), values.size() * sizeof(float_type));\n```\n\n## References\n- [OWASP C-Based Toolchain Hardening Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [NIST Buffer Overflow](https://csrc.nist.gov/glossary/term/buffer_overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n\n___\n"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "d3e64a1b-2e1f-3be7-a4e7-ea2dd7741965",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fdeep/tensor.hpp"
                },
                "region": {
                  "startLine": 927,
                  "startColumn": 13,
                  "endLine": 927,
                  "endColumn": 60,
                  "charOffset": 39555,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(result->data(), m.data(), result->size()",
                    "rendered": {
                      "text": "memcpy(result->data(), m.data(), result->size()",
                      "markdown": "`memcpy(result->data(), m.data(), result->size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fdeep/tensor.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39555,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(result->data(), <size of result->data()>,  m.data(),  result->size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "39ab219f-8268-3ae0-b7c6-ca4b687357ea",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/fdeep/tensor.hpp"
                },
                "region": {
                  "startLine": 919,
                  "startColumn": 13,
                  "endLine": 919,
                  "endColumn": 58,
                  "charOffset": 39215,
                  "charLength": 45,
                  "snippet": {
                    "text": "memcpy(m.data(), values.data(), values.size()",
                    "rendered": {
                      "text": "memcpy(m.data(), values.data(), values.size()",
                      "markdown": "`memcpy(m.data(), values.data(), values.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/fdeep/tensor.hpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39215,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m.data(), <size of m.data()>,  values.data(),  values.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}